# Распределенные операционные системы.

## 1. Модель распределенной системы

- **Распределенная система** – это совокупность нескольких узлов (компьютеров), которые работают вместе, чтобы достичь
  общей цели. Узлы обмениваются сообщениями через сеть и выглядят для пользователя как единая система. Примером может
  быть облачная система, где множество серверов обслуживают пользователей.
- Основные характеристики модели:
    - **Прозрачность** – система должна скрывать от пользователя сложность взаимодействий между узлами.
    - **Распределенность** – компоненты работают на разных узлах, что позволяет повышать производительность и
      отказоустойчивость.
    - **Асинхронность** – процессы не обязаны выполнять операции одновременно.
- **Пример**: В онлайн-магазине серверы распределены по регионам, но пользователь видит единый интерфейс. Если один
  сервер выходит из строя, его заменяет другой, и работа продолжается.

## 2. Глобальные состояния распределенной системы

- **Глобальное состояние** – это моментальная "снимка" всей системы, включающая:
    - Состояние всех узлов (процессов) – например, значения переменных и состояние выполнения процессов.
    - Сообщения, которые находятся в пути между узлами – это важно, так как они могут повлиять на поведение системы.
- **Алгоритм Чанди-Лампорт** используется для согласованного фиксирования глобального состояния. Основная идея:
    - Каждый узел отправляет свои локальные состояния соседям.
    - Включаются только сообщения, которые уже "в пути".
    - Это позволяет зафиксировать корректное состояние даже при асинхронной работе узлов.
- **Пример**: Представьте банк с несколькими филиалами. Чтобы понять, сколько денег у банка в целом, нужно учитывать
  состояние каждого филиала и те переводы, которые уже отправлены, но еще не дошли.

## 3. Слабо справедливое выполнение распределенной системы

- **Слабая справедливость** означает, что если какой-то процесс многократно имеет возможность выполнить действие, то
  рано или поздно оно будет выполнено.
- Важно понимать, что здесь не гарантируется равномерность выполнения действий – одни процессы могут выполняться чаще,
  чем другие.
- **Пример**: Представьте очередь на выполнение задач. Если задачи поступают от нескольких процессов, но один из
  процессов отправляет задачи чаще, то остальные все равно будут иметь возможность выполнения, хотя, возможно, реже.
- **Преподаватель может уточнить**: как это связано с реальными системами? Ответ: Слабая справедливость применима в
  системах, где важна гарантия выполнения, но не обязательно равномерное распределение ресурсов, например, в
  многозадачном планировании ОС.

## 4. Сильно справедливое выполнение распределенной системы

- **Сильная справедливость** – более жесткое требование. Она гарантирует, что, если процесс может выполнять действие, он
  будет выполнять его равномерно с другими. Никто не может быть "забыт".
- **Пример**: Представьте систему, которая распределяет доступ к ресурсам между несколькими пользователями. При сильной
  справедливости каждый пользователь получит равный доступ, даже если один из них постоянно посылает запросы, а другие
  делают это реже.
- **Различие с слабой справедливостью**: слабая справедливость гарантирует выполнение, но не равномерное, а сильная –
  именно равномерность.
- **Преподаватель может спросить**: зачем это нужно? Ответ: это важно в системах, где критически важно справедливое
  распределение ресурсов, например, в банковских системах, где все клиенты должны получить равные шансы на выполнение
  транзакций.

## 5. Свойство живучести распределенной системы

- **Живучесть (liveness)** – это свойство, которое гарантирует, что "хорошие вещи" в системе обязательно произойдут.
- Например, если в системе отправлен запрос, он обязательно будет обработан.
- Чтобы достичь живучести:
    - Используют механизмы восстановления – если один компонент выходит из строя, другой берет на себя его функции.
    - Репликацию данных – копии хранятся на разных узлах, чтобы избежать потери.
    - Контроль отказов – система должна уметь обнаруживать сбои и восстанавливаться.
- **Пример**: В системе интернет-банкинга, если один сервер выходит из строя, другой берет на себя его задачи, чтобы
  пользователь мог продолжить работу.
- **Преподаватель может уточнить**: как это достигается? Ответ: с помощью алгоритмов согласования и балансировки
  нагрузки. Например, система может автоматически перенаправлять запросы на доступные узлы.

## 6. Архитектура приложения

- **Архитектура распределенного приложения** определяет, как компоненты взаимодействуют друг с другом в распределенной
  системе.
- Существует несколько видов архитектур:
    - **Клиент-сервер** – клиент запрашивает данные у сервера. Например, веб-приложение, где браузер является клиентом.
    - **Многоуровневая архитектура (n-tier)** – добавляются промежуточные уровни, например, слой бизнес-логики. Пример –
      веб-сайты с базой данных.
    - **Архитектура peer-to-peer (P2P)** – все узлы равноправны, как в торрентах.
- Архитектура влияет на производительность, масштабируемость и отказоустойчивость системы.
- **Преподаватель может спросить**: зачем нужны такие уровни? Ответ: это помогает разделить задачи, упростить
  масштабирование и изоляцию проблем.

## 7. Межпроцессорное взаимодействие

- **Межпроцессорное взаимодействие (IPC)** – это способ обмена данными между процессами, работающими на одном или разных
  узлах системы.
- Основные механизмы IPC:
    - **Сообщения (message passing)** – процессы отправляют сообщения друг другу. Например, протокол HTTP.
    - **Разделяемая память (shared memory)** – процессы имеют доступ к общей области памяти.
    - **Сокеты (sockets)** – интерфейс для сетевого взаимодействия, например, TCP/IP.
    - **Очереди сообщений и каналы** – буферизация данных для асинхронного взаимодействия.
- **Преподаватель может уточнить**: какие проблемы возникают? Ответ: Синхронизация данных, управление доступом и
  возможные конфликты.

## 8. Неблокирующий примитив

- **Неблокирующие примитивы** – это механизмы взаимодействия, которые позволяют процессу продолжать выполнение без
  ожидания завершения операции.
- Примеры:
    - **Неблокирующий ввод-вывод** – процесс может запросить чтение данных, а затем продолжать выполнение других задач,
      пока данные не станут доступны.
    - **Compare-and-swap (CAS)** – атомарная операция, используемая для синхронизации потоков без блокировки.
- Преимущество: высокая производительность, так как процессоры не простаивают.
- Недостаток: сложность программирования и отладки.
- **Пример**: веб-сервер, который обрабатывает несколько запросов одновременно, не дожидаясь завершения каждого запроса.

## 9. Централизованная служба имен

- **Централизованная служба имен** используется для управления именами объектов в системе. Например, DNS (Domain Name
  System) преобразует имена доменов в IP-адреса.
- Особенности:
    - Единая точка управления – все запросы направляются на один сервер.
    - Простота реализации – система легко управляется и масштабируется для небольших сетей.
- Недостатки: уязвимость к сбоям сервера, сложность обслуживания при большом количестве запросов.
- **Преподаватель может спросить**: как это применяется? Ответ: например, в корпоративных сетях для поиска ресурсов (
  принтеров, файловых серверов).

## 10. Связывание сокета с адресом

- **Связывание сокета с адресом** – это процесс, при котором сокету (сетевому интерфейсу) присваивается IP-адрес и порт.
- Основные шаги:
    - Создается сокет с помощью системного вызова (например, socket() в C).
    - Вызывается функция bind() для связывания с адресом и портом.
    - Сокет начинает слушать подключения (для серверов) или отправлять запросы (для клиентов).
- **Пример**: В веб-приложении сервер связывается с портом 80, чтобы обрабатывать HTTP-запросы.
- **Преподаватель может спросить**: что, если порт занят? Ответ: Порт должен быть освобожден, или необходимо выбрать
  другой.

## 11. Вызов локальных процедур

- **Вызов локальных процедур (Local Procedure Call, LPC)** – это механизм, позволяющий процессу вызывать процедуру,
  которая выполняется в пределах одного узла. Это упрощает взаимодействие между процессами, работающими на одной
  системе.
- **Пример работы**:
    - Процесс вызывает локальную процедуру через системный интерфейс.
    - Передача управления и данных происходит через локальную память.
    - После выполнения процедуры возвращается результат.
- Различие с удалённым вызовом процедур (RPC): в LPC нет сетевого взаимодействия, что делает его более быстрым, но
  ограниченным одним узлом.
- **Преподаватель может спросить**: почему это важно в распределённых системах? Ответ: LPC снижает нагрузку на сеть,
  улучшая производительность при локальных взаимодействиях.

## 12. Автоматический способ генерации стабов

- **Стабы (stubs)** – посредники, позволяющие вызывать удалённые процедуры как локальные.
- **Автоматическая генерация стабов**:
    - Интерфейс процедур описывается на языке **IDL (Interface Definition Language)**.
    - Специальный компилятор создаёт клиентский и серверный стабы.
    - Клиентский стаб преобразует вызов в сообщение, серверный – обратно.
- **Пример**: В CORBA используется IDL для генерации стабов.
- **Вопрос преподавателя**: Зачем это нужно?  
  **Ответ**: Упрощает разработку, снимая необходимость писать сложный код для сетевого взаимодействия.
- 
## 13. Методы связывания в реализациях RPC

- **Связывание** – процесс установления связи между клиентом и сервером для RPC.
- Основные методы:
    - **Статическое связывание** – связь устанавливается во время компиляции, сервер известен заранее.
    - **Динамическое связывание** – связь устанавливается во время выполнения, клиент запрашивает адрес сервера у службы
      имен.
    - **Имплицитное связывание** – клиент взаимодействует через посредника.
- **Пример**: В Java RMI используется динамическое связывание через реестр RMI.
- **Вопрос преподавателя**: Какой метод лучше?  
  **Ответ**: Динамическое связывание более гибкое, но сложнее в реализации.

## 14. Механизмы SUN RPC

- **SUN RPC** – реализация RPC от Sun Microsystems.
- Основные механизмы:
    - **Язык XDR (External Data Representation)** для описания структур данных и процедур.
    - **Стабы**, генерируемые для клиента и сервера.
    - **Протоколы**:
        - RPC-протокол для вызовов.
        - UDP/TCP для передачи сообщений.
- **Пример**: NFS использует SUN RPC для обмена данными.
- **Вопрос преподавателя**: Какие недостатки?  
  **Ответ**: Менее эффективен для сложных систем из-за использования статического связывания.

## 15. Процедуры DCE RPC

- **DCE RPC** – усовершенствованная версия RPC от Open Group.
- Особенности:
    - Поддержка разных протоколов (TCP/IP, NetBIOS).
    - Аутентификация и шифрование для безопасности.
    - Универсальный интерфейс IDL.
- **Пример**: Использовался в Windows NT для связи между узлами.
- **Вопрос преподавателя**: Чем отличается от SUN RPC?  
  **Ответ**: DCE RPC более безопасен и гибок благодаря поддержке аутентификации и мультипротокольности.

## 16. Файловые службы в распределённых файловых системах

- **Файловые службы** предоставляют доступ к удалённым файлам как к локальным.
- Основные функции:
    - Хранение файлов.
    - Обеспечение доступа (чтение, запись, изменение).
    - Механизмы защиты.
- **Пример**: NFS позволяет подключить удалённую файловую систему.
- **Вопрос преподавателя**: Зачем это нужно?  
  **Ответ**: Упрощает управление данными и объединяет ресурсы.

## 17. Сетевая файловая система

- **NFS (Network File System)** – пример распределённой файловой системы.
- Особенности:
    - Прозрачность – работа с файлами как с локальными.
    - Простота подключения – через команды монтирования.
    - Использует протокол SUN RPC.
- **Пример использования**: Офисные сети для общего доступа к файлам.
- **Вопрос преподавателя**: В чём недостатки?  
  **Ответ**: Проблемы с производительностью при высокой нагрузке или отказе сети.

## 18. Разделяемые файлы и ACL

- **Разделяемые файлы** – используются одновременно несколькими пользователями или процессами.
- **Списки управления доступом (ACL)**:
    - Описывают, кто и какие действия может выполнять.
    - Реализуются на уровне файловой системы.
- **Пример**: В UNIX права доступа задаются через команды `chmod` и `setfacl`.
- **Вопрос преподавателя**: Зачем нужен ACL?  
  **Ответ**: Для разграничения доступа и обеспечения безопасности.

## 19. Файловые серверы типа stateful

- **Stateful серверы** сохраняют информацию о состоянии клиента.
- Особенности:
    - Хранение информации об открытых файлах и позициях чтения/записи.
    - **Преимущества**: эффективность работы.
    - **Недостаток**: потеря состояния при сбое.
- **Пример**: Сервер ускоряет обработку запросов, зная об открытых файлах.

## 20. Файловые серверы типа stateless

- **Stateless серверы** не хранят информацию о состоянии клиента.
- Особенности:
    - Каждый запрос содержит всю необходимую информацию.
    - **Преимущества**: отказоустойчивость.
    - **Недостаток**: дополнительная нагрузка на сеть.
- **Пример**: NFS в режиме stateless.

## 21. Схемы кэширования в файловых системах

- **Кэширование** ускоряет доступ к данным и снижает сетевые операции.
- Схемы:
    - Кэширование на стороне клиента (локальное хранилище данных).
    - Кэширование на стороне сервера (быстрый доступ к часто запрашиваемым данным).
    - Кэширование на уровне сети.
- Решения проблем синхронизации:
    - **Write-through** – немедленное сохранение изменений на сервере.
    - **Write-back** – сохранение изменений с задержкой.
- **Вопрос преподавателя**: Зачем это нужно?  
  **Ответ**: Для повышения производительности и уменьшения нагрузки.

## 22. Репликация

- **Репликация** – создание копий данных на нескольких узлах.
- Цели:
    - Повышение доступности.
    - Ускорение доступа.
    - Повышение отказоустойчивости.
- **Пример**: В облачных системах данные реплицируются на нескольких серверах.
- **Недостаток**: сложность синхронизации данных.

## 23. Прозрачность репликаций в сетевых файловых системах

- **Прозрачность репликаций** скрывает наличие нескольких копий данных.
- Преимущества:
    - Упрощение работы пользователя.
    - Повышение производительности.
- **Пример**: Google Drive автоматически выбирает реплику.
- **Вопрос преподавателя**: Что сложного в реализации?  
  **Ответ**: Согласованность данных и распределение нагрузки.

## 24. Способы согласования реплик

- Методы согласования:
    - **Мастер-реплика** – изменения записываются в основную копию.
    - **Многомастерное согласование** – изменения вносятся в любую реплику с последующей синхронизацией.
    - **Консистентное согласование** – обновление всех реплик одновременно.
- **Пример**: Git использует многомастерное согласование.
- **Недостаток**: задержки и конфликты при обновлениях.

## 25. Протокол передачи файлов FTP

- **FTP (File Transfer Protocol)** – протокол передачи файлов между клиентом и сервером.
- Особенности:
    - **Клиент-серверная модель**.
    - **Два соединения**: управляющее (команды) и данные (файлы).
    - **Поддержка авторизации**.
- **Пример**: Хостинг-платформы для загрузки веб-файлов.
- **Недостаток**: данные передаются незашифрованными. Альтернатива – **SFTP (Secure FTP)**.

## 26. Общая схема взаимодействия клиента и сервера. FTP
## 27. Команды взаимодействия. FTP)
## 28. Команды службы FTP просмотра удаленного диалога
## 29. Файловая система NFS
## 30. Назначение и принципы организации службы каталогов
## 31. Стандар Х.500
## 32. Стандарт LDAP
## 33. Служба каталогов NDS
## 34. Разделы БД NDS
## 35. Дерево каталогов NDS
## 36. Служба NDS и файловая система
## 37. Средства защиты объектов в NDS
## 38. Типы реплик NDS 
